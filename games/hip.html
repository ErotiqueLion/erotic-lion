<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>怪奇！尻叩きサーカス</title>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts: Rye (Circus/Western style) -->
    <link href="https://fonts.googleapis.com/css2?family=Rye&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0505; 
            font-family: 'Rye', serif;
            touch-action: none;
            color: #d4af37;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 2px 2px 4px #000;
        }

        .hud-text {
            font-size: 28px;
            color: #f0e68c;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #8b4513;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.9);
        }

        #quit-btn {
            pointer-events: auto;
            background: #500000;
            color: #fff;
            border: 2px solid #8b0000;
            padding: 10px 20px;
            font-family: 'Rye', serif;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: inset 0 0 10px #000;
        }
        #quit-btn:active {
            background: #300000;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #2a0505 10%, #000000 90%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            border: 20px solid #1a0a05;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            color: #ff2200;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0000, 3px 3px 0 #000;
            letter-spacing: 2px;
            text-align: center;
            font-weight: normal;
        }

        p {
            color: #cdb38b;
            font-size: 18px;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.6;
            max-width: 80%;
            text-shadow: 1px 1px 2px #000;
        }

        .warning {
            color: #ff0000;
            font-size: 16px;
            display: block;
            margin-top: 10px;
            text-shadow: 0 0 5px #ff0000;
        }

        button.start-btn {
            background: linear-gradient(to bottom, #b8860b, #553300);
            border: 4px double #ffd700;
            color: #fff;
            font-family: 'Rye', serif;
            font-size: 28px;
            padding: 15px 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.4);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-shadow: 1px 1px 0 #000;
        }

        button.start-btn:active {
            transform: scale(0.95);
        }

        /* 戻るボタンのスタイル */
        #back-link {
            margin-top: 25px;
            color: #d4af37;
            text-decoration: none;
            font-family: 'Rye', serif;
            font-size: 20px;
            border: 2px solid #d4af37;
            padding: 8px 30px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #back-link:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 10px #d4af37;
        }

        .hit-text {
            position: absolute;
            color: #ff0000;
            font-family: 'Rye', serif;
            font-weight: bold;
            font-size: 40px;
            pointer-events: none;
            text-shadow: 3px 3px 0 #000, 0 0 15px #ff0000;
            animation: popUp 0.6s forwards;
            z-index: 5;
            white-space: nowrap;
        }

        @keyframes popUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5) rotate(-15deg); }
            40% { transform: translate(-50%, -120%) scale(1.3) rotate(15deg); }
            100% { opacity: 0; transform: translate(-50%, -180%) scale(1.0); }
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="header">
            <div class="hud-text" id="score-board">SCORE: 0</div>
            <button id="quit-btn">STOP</button>
        </div>
        <div style="text-align: center;">
            <div class="hud-text" id="timer">TIME: 30</div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">THE SPANKING<br>CIRCUS</h1>
        <p id="desc-text">Ladies and Gentlemen...<br>今宵の出し物は「尻叩き」でございます。<br>パンツを吹き飛ばし、悲鳴を上げさせましょう...<br><span class="warning">※異形の尻（おじさん）には触れてはいけません...</span></p>
        <button id="start-btn" class="start-btn">ENTER SHOW</button>
        <!-- 戻るボタン -->
        <a id="back-link" href="https://erotiquelion.github.io/erotic-lion/">EXIT CIRCUS</a>
    </div>

    <script>
        const GAME_DURATION = 30; 
        const GRID_SIZE = 3; 
        const HOLE_SPACING = 2.5;
        let score = 0;
        let isPlaying = false;
        let timeLeft = GAME_DURATION;
        
        let scene, camera, renderer, raycaster;
        let targets = []; 
        let mouse = new THREE.Vector2();
        let particles = []; 
        
        // --- AudioContext ---
        let audioCtx;
        let bgmTimerId;
        const noteLength = 0.35; 
        let sequenceIndex = 0;

        const melody = [
            { freq: 69.30, type: 'bass', dur: 1.0 }, { freq: 329.63, type: 'chord', dur: 0.2 }, { freq: 311.13, type: 'chord', dur: 0.2 },
            { freq: 98.00, type: 'bass', dur: 1.0 }, { freq: 369.99, type: 'chord', dur: 0.2 }, { freq: 349.23, type: 'chord', dur: 0.2 },
            { freq: 65.41, type: 'bass', dur: 1.0 }, { freq: 293.66, type: 'chord', dur: 0.2 }, { freq: 277.18, type: 'chord', dur: 0.2 },
            { freq: 92.50, type: 'bass', dur: 1.0 }, { freq: 440.00, type: 'chord', dur: 0.2 }, { freq: 415.30, type: 'chord', dur: 0.2 },
        ];

        const speechSynth = window.speechSynthesis;
        let jpVoice = null;
        let maleVoice = null;

        // --- テクスチャ生成関数 ---

        // 1. リアルな肌テクスチャ（女の子用）
        function createSkinTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#ffffff'; 
            ctx.fillRect(0, 0, 256, 256);
            
            const imgData = ctx.getImageData(0,0, 256, 256);
            for (let i = 0; i < imgData.data.length; i += 4) {
                const grain = (Math.random() - 0.5) * 15;
                imgData.data[i] = Math.max(0, Math.min(255, imgData.data[i] + grain));
                imgData.data[i+1] = Math.max(0, Math.min(255, imgData.data[i+1] + grain));
                imgData.data[i+2] = Math.max(0, Math.min(255, imgData.data[i+2] + grain));
            }
            ctx.putImageData(imgData, 0, 0);
            
            const grad = ctx.createRadialGradient(128, 128, 50, 128, 128, 128);
            grad.addColorStop(0, 'rgba(255,255,255,0)');
            grad.addColorStop(1, 'rgba(230,220,220,0.3)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,256,256);

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // 2. おじさんのグロテスク肌テクスチャ
        function createUncleSkinTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // ベース：不健康な土気色/くすんだ紫
            ctx.fillStyle = '#7a6a6a'; 
            ctx.fillRect(0, 0, 256, 256);
            
            // ノイズ（汚し）強め
            const imgData = ctx.getImageData(0,0, 256, 256);
            for (let i = 0; i < imgData.data.length; i += 4) {
                const grain = (Math.random() - 0.5) * 50; 
                imgData.data[i] += grain;
                imgData.data[i+1] += grain;
                imgData.data[i+2] += grain;
            }
            ctx.putImageData(imgData, 0, 0);

            // 血管（青紫、赤黒い線）
            ctx.lineWidth = 1.5;
            for(let i=0; i<15; i++) {
                ctx.beginPath();
                ctx.strokeStyle = Math.random() > 0.5 ? 'rgba(80, 0, 0, 0.4)' : 'rgba(0, 0, 80, 0.3)';
                let x = Math.random() * 256;
                let y = Math.random() * 256;
                ctx.moveTo(x, y);
                for(let j=0; j<5; j++) {
                    x += (Math.random()-0.5)*60;
                    y += (Math.random()-0.5)*60;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // シミ
            ctx.fillStyle = 'rgba(50, 30, 20, 0.3)';
            for(let i=0; i<30; i++) {
                 ctx.beginPath();
                 ctx.arc(Math.random()*256, Math.random()*256, Math.random()*15, 0, Math.PI*2);
                 ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // 3. レース生地のパンティテクスチャ（線を濃く）
        function createLaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#ffffff'; 
            ctx.fillRect(0,0,128,128);
            
            ctx.strokeStyle = 'rgba(180,180,180,0.5)'; 
            ctx.lineWidth = 1;
            for(let i=0; i<128; i+=6) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,128); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(128,i); ctx.stroke();
            }
            
            ctx.fillStyle = 'rgba(220,220,220, 0.8)';
            for(let i=0; i<30; i++) {
                const x = Math.random()*128;
                const y = Math.random()*128;
                const r = Math.random()*4 + 2;
                ctx.beginPath(); ctx.arc(x,y, r, 0, Math.PI*2); ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(2, 2);
            return tex;
        }

        // 4. おじさんのストライプパンツ
        function createStripedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2b2b2b'; // より暗く
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#3f3f3f';
            for(let i=0; i<128; i+=16) ctx.fillRect(i,0,8,128);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 2);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const skinTexture = createSkinTexture();
        const uncleSkinTexture = createUncleSkinTexture();
        const laceTexture = createLaceTexture();
        const trunksTexture = createStripedTexture();

        // --- Audio Functions ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playBGM() {
            if (!audioCtx) return;
            sequenceIndex = 0;
            scheduler();
        }

        function scheduler() {
            if (!isPlaying) return;
            const time = audioCtx.currentTime;
            const beat = sequenceIndex % 3;
            const bar = Math.floor(sequenceIndex / 3) % (melody.length / 3);
            const noteIdx = (bar * 3) + beat;
            playNote(melody[noteIdx], time);
            sequenceIndex++;
            bgmTimerId = setTimeout(scheduler, noteLength * 1000);
        }

        function playNote(note, time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const lfo = audioCtx.createOscillator(); 
            const lfoGain = audioCtx.createGain();

            osc.type = note.type === 'bass' ? 'sawtooth' : 'square';
            osc.frequency.value = note.freq;

            lfo.type = 'sine';
            lfo.frequency.value = 2.0; 
            lfoGain.gain.value = 5.0; 

            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            lfo.start(time);

            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(note.type === 'bass' ? 0.3 : 0.08, time + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, time + noteLength * 0.9);

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(time);
            osc.stop(time + noteLength);
        }

        function stopBGM() {
            if (bgmTimerId) clearTimeout(bgmTimerId);
        }

        function playSlapSound() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 0.1; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1200;

            noise.connect(filter);
            filter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noiseGain.gain.setValueAtTime(1.0, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            noise.start(t);
        }

        function loadVoices() {
            const voices = speechSynth.getVoices();
            // 女の子用
            jpVoice = voices.find(v => v.lang === 'ja-JP' && v.name.includes('Google')) || voices.find(v => v.lang === 'ja-JP') || null;
            // おじさん用（できるだけ低い声）
            maleVoice = voices.find(v => v.name.includes('Ichiro')) || 
                        voices.find(v => v.name.includes('Ken')) ||    
                        voices.find(v => v.name.toLowerCase().includes('male')) ||
                        null; 
        }
        speechSynth.onvoiceschanged = loadVoices;

        // --- Three.js Init ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000); 
            scene.fog = new THREE.Fog(0x050000, 4, 20); 

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 9);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.0;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffaa55, 1.5); 
            spotLight.position.set(0, 15, 2);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);

            const bottomLight = new THREE.PointLight(0x550000, 1, 10);
            bottomLight.position.set(0, -2, 2);
            scene.add(bottomLight);

            const floorGeo = new THREE.PlaneGeometry(50, 50);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x221100, roughness: 0.9, metalness: 0.1
            });
            const ground = new THREE.Mesh(floorGeo, floorMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createGameGrid();

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            raycaster = new THREE.Raycaster();
            animate();
        }

        function createGameGrid() {
            const offset = (GRID_SIZE - 1) * HOLE_SPACING / 2;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    const posX = x * HOLE_SPACING - offset;
                    const posZ = z * HOLE_SPACING - offset;

                    const rimGeo = new THREE.TorusGeometry(0.9, 0.05, 16, 32);
                    const rimMat = new THREE.MeshStandardMaterial({ color: 0x554433, roughness: 0.8 });
                    const rim = new THREE.Mesh(rimGeo, rimMat);
                    rim.rotation.x = -Math.PI / 2;
                    rim.position.set(posX, 0.02, posZ);
                    rim.receiveShadow = true;
                    scene.add(rim);

                    const holeGeo = new THREE.CircleGeometry(0.85, 32);
                    const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const hole = new THREE.Mesh(holeGeo, holeMat);
                    hole.rotation.x = -Math.PI / 2;
                    hole.position.set(posX, 0.03, posZ);
                    scene.add(hole);

                    const target = new ButtTarget(scene, posX, posZ);
                    targets.push(target);
                }
            }
        }

        // --- ターゲットクラス ---
        class ButtTarget {
            constructor(scene, x, z) {
                this.state = 'HIDDEN'; 
                this.type = 'NORMAL'; 
                this.timer = 0;
                this.baseY = -2.2; 
                this.visibleY = 0.5;
                
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, this.baseY, z);

                // --- お尻本体 ---
                const cheekGeo = new THREE.SphereGeometry(0.65, 32, 32);
                this.skinMat = new THREE.MeshStandardMaterial({ 
                    map: skinTexture,
                    color: 0xffe4e1, 
                    roughness: 0.4,
                });

                const leftCheek = new THREE.Mesh(cheekGeo, this.skinMat);
                leftCheek.position.set(-0.48, 0, 0);
                leftCheek.scale.set(1.0, 1.15, 0.95); 
                leftCheek.rotation.z = -Math.PI / 12; 
                leftCheek.castShadow = true;
                
                const rightCheek = new THREE.Mesh(cheekGeo, this.skinMat);
                rightCheek.position.set(0.48, 0, 0);
                rightCheek.scale.set(1.0, 1.15, 0.95);
                rightCheek.rotation.z = Math.PI / 12;
                rightCheek.castShadow = true;

                this.mesh.add(leftCheek);
                this.mesh.add(rightCheek);

                // --- 服グループ ---
                this.clothesGroup = new THREE.Group();
                this.mesh.add(this.clothesGroup);

                // ======================================
                // 女の子パンティグループ
                // ======================================
                this.pantyGroup = new THREE.Group();
                this.clothesGroup.add(this.pantyGroup);

                this.pantyMat = new THREE.MeshStandardMaterial({
                    map: laceTexture,
                    color: 0xffffff,
                    roughness: 0.6,
                    metalness: 0.1
                });

                // パンティ本体
                const pCheekGeo = new THREE.SphereGeometry(0.66, 32, 32);
                const pLeft = new THREE.Mesh(pCheekGeo, this.pantyMat);
                pLeft.position.set(-0.48, 0.08, 0.05); 
                pLeft.scale.set(1.02, 0.95, 0.9); 
                pLeft.rotation.z = -Math.PI / 10;

                const pRight = new THREE.Mesh(pCheekGeo, this.pantyMat);
                pRight.position.set(0.48, 0.08, 0.05);
                pRight.scale.set(1.02, 0.95, 0.9);
                pRight.rotation.z = Math.PI / 10;

                const gussetGeo = new THREE.BoxGeometry(0.3, 0.1, 0.4);
                const gusset = new THREE.Mesh(gussetGeo, this.pantyMat);
                gusset.position.set(0, -0.6, 0.2);
                gusset.rotation.x = Math.PI / 4;

                const frillGeo = new THREE.TorusGeometry(1.0, 0.06, 6, 32); 
                const frill = new THREE.Mesh(frillGeo, this.pantyMat);
                frill.rotation.x = Math.PI / 2;
                frill.position.y = 0.55;
                frill.scale.set(1.1, 0.65, 1);

                this.ribbon = new THREE.Group();
                this.ribbon.position.set(0, 0.55, 0.65); 
                const bowGeo = new THREE.ConeGeometry(0.15, 0.3, 16);
                const bowL = new THREE.Mesh(bowGeo, new THREE.MeshStandardMaterial({color:0xff69b4}));
                bowL.rotation.z = Math.PI/2.5;
                bowL.position.x = -0.15;
                const bowR = new THREE.Mesh(bowGeo, new THREE.MeshStandardMaterial({color:0xff69b4}));
                bowR.rotation.z = -Math.PI/2.5;
                bowR.position.x = 0.15;
                const bowC = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color:0xff69b4}));
                this.ribbon.add(bowL, bowR, bowC);

                this.pantyGroup.add(pLeft, pRight, gusset, frill, this.ribbon);

                // ======================================
                // おじさんトランクスグループ
                // ======================================
                this.trunksGroup = new THREE.Group();
                this.clothesGroup.add(this.trunksGroup);
                this.trunksGroup.visible = false;

                this.trunksMat = new THREE.MeshStandardMaterial({
                    map: trunksTexture,
                    roughness: 0.9
                });

                const tCheekGeo = new THREE.SphereGeometry(0.67, 32, 32);
                const tLeft = new THREE.Mesh(tCheekGeo, this.trunksMat);
                tLeft.position.copy(leftCheek.position);
                tLeft.scale.set(1.05, 1.2, 1.0); 
                tLeft.rotation.copy(leftCheek.rotation);
                
                const tRight = new THREE.Mesh(tCheekGeo, this.trunksMat);
                tRight.position.copy(rightCheek.position);
                tRight.scale.set(1.05, 1.2, 1.0);
                tRight.rotation.copy(rightCheek.rotation);

                const legGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.7, 16);
                const leftLeg = new THREE.Mesh(legGeo, this.trunksMat);
                leftLeg.position.set(-0.4, -0.6, 0);
                leftLeg.rotation.z = Math.PI / 12;
                
                const rightLeg = new THREE.Mesh(legGeo, this.trunksMat);
                rightLeg.position.set(0.4, -0.6, 0);
                rightLeg.rotation.z = -Math.PI / 12;

                const tWaistGeo = new THREE.TorusGeometry(1.05, 0.08, 6, 32);
                const tWaist = new THREE.Mesh(tWaistGeo, new THREE.MeshStandardMaterial({color: 0x222222})); 
                tWaist.rotation.x = Math.PI / 2;
                tWaist.position.y = 0.6;
                tWaist.scale.set(1.1, 0.6, 1);

                this.trunksGroup.add(tLeft, tRight, leftLeg, rightLeg, tWaist);

                this.hairGroup = new THREE.Group();
                const hairGeo = new THREE.PlaneGeometry(0.02, 0.1);
                const hairMat = new THREE.MeshBasicMaterial({color: 0x111111, side: THREE.DoubleSide});
                for(let i=0; i<60; i++) { // 毛量増加
                    const hair = new THREE.Mesh(hairGeo, hairMat);
                    hair.position.set(
                        (Math.random() - 0.5) * 0.4, 
                        (Math.random() - 0.5) * 0.5 - 0.1, 
                        0.6 + Math.random() * 0.1 
                    );
                    hair.rotation.set(Math.random(), Math.random(), Math.random());
                    this.hairGroup.add(hair);
                }
                this.mesh.add(this.hairGroup);
                this.hairGroup.visible = false;

                const baseGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.0, 32); 
                const baseMat = new THREE.MeshStandardMaterial({ color: 0x1a0a05, roughness: 1.0 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = -1.0;
                this.mesh.add(base);

                this.mesh.traverse((obj) => {
                    if (obj.isMesh) obj.userData = { parent: this };
                });

                scene.add(this.mesh);
            }

            reset(isUncle) {
                this.state = 'HIDDEN';
                this.mesh.position.y = this.baseY;
                
                this.type = isUncle ? 'UNCLE' : 'NORMAL';

                if (this.type === 'UNCLE') {
                    // おじさん（グロテスク化）
                    this.skinMat.map = uncleSkinTexture;
                    this.skinMat.color.setHex(0xffffff); // テクスチャの色をそのまま使う
                    this.skinMat.roughness = 1.0;
                    this.pantyGroup.visible = false;
                    this.trunksGroup.visible = true;
                    this.hairGroup.visible = true; 
                } else {
                    // 女の子
                    this.skinMat.map = skinTexture;
                    this.skinMat.color.setHex(0xffd1dc); 
                    this.skinMat.roughness = 0.3;
                    this.pantyGroup.visible = true;
                    this.trunksGroup.visible = false;
                    this.hairGroup.visible = false;
                    
                    // パンティの色
                    const colors = [0xff1493, 0x00bfff, 0x111111, 0xff0000, 0x800080];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    this.pantyMat.color.setHex(color);
                    
                    const ribbonColor = (color === 0xffffff) ? 0xff69b4 : 0xffffff;
                    this.ribbon.children.forEach(c => c.material.color.setHex(ribbonColor));
                }
            }

            update(delta) {
                if (this.state === 'RISING') {
                    this.mesh.position.y += delta * 6;
                    if (this.mesh.position.y >= this.visibleY) {
                        this.mesh.position.y = this.visibleY;
                        this.state = 'VISIBLE';
                        this.timer = 0;
                    }
                } else if (this.state === 'VISIBLE') {
                    this.timer += delta;
                    this.mesh.rotation.z = Math.sin(this.timer * 2.5) * 0.08;
                    if (this.timer > 1.3) { 
                        this.state = 'HIDING';
                    }
                } else if (this.state === 'HIDING') {
                    this.mesh.position.y -= delta * 4;
                    this.mesh.rotation.z = 0;
                    if (this.mesh.position.y <= this.baseY) {
                        this.mesh.position.y = this.baseY;
                        this.state = 'HIDDEN';
                    }
                } else if (this.state === 'HIT') {
                    this.timer += delta;
                    
                    // セクシーな揺れ（Jiggle Physics）
                    // 減衰係数
                    const decay = Math.max(0, 1 - this.timer * 2.5);
                    
                    // 伸縮（Squash & Stretch）: 縦横に逆位相で伸縮させる
                    const frequency = 25; // 揺れの速さ
                    const elasticity = 0.15; // 弾力性
                    const squash = Math.sin(this.timer * frequency) * elasticity * decay;
                    this.mesh.scale.set(1 + squash, 1 - squash, 1);
                    
                    // 横揺れ（Wobble）
                    this.mesh.rotation.z = Math.sin(this.timer * 20) * 0.15 * decay;

                    if (this.timer > 0.5 && this.type !== 'UNCLE') {
                        // 形状を戻す
                        this.mesh.scale.set(1,1,1);
                        this.mesh.rotation.z = 0;
                        this.state = 'HIDING';
                    }
                }
            }

            appear() {
                if (this.state === 'HIDDEN') {
                    const isUncle = Math.random() < 0.2;
                    this.reset(isUncle);
                    this.state = 'RISING';
                    this.mesh.rotation.y = (Math.random() - 0.5) * 0.3; 
                }
            }

            hit() {
                if (this.state === 'RISING' || this.state === 'VISIBLE') {
                    this.state = 'HIT';
                    this.timer = 0;
                    
                    if (this.type === 'UNCLE') {
                        return 'GAME_OVER';
                    } else {
                        this.pantyGroup.visible = false;
                        return 'HIT';
                    }
                }
                return false;
            }
        }

        // --- パーティクル ---
        function createConfetti(x, y, z, color) {
            const particleCount = 40;
            const geometry = new THREE.PlaneGeometry(0.15, 0.15); 
            const material = new THREE.MeshBasicMaterial({
                color: color, 
                side: THREE.DoubleSide
            });
            
            for(let i=0; i<particleCount; i++) {
                const p = new THREE.Mesh(geometry, material);
                p.position.set(x, y, z);
                
                const theta = Math.random() * Math.PI * 2;
                const force = Math.random() * 5 + 3;

                p.userData = {
                    vel: new THREE.Vector3(
                        Math.cos(theta) * force,
                        Math.random() * 5 + 2,
                        Math.sin(theta) * force
                    ),
                    rotVel: new THREE.Vector3(
                        Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5
                    )
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.addScaledVector(p.userData.vel, delta);
                p.rotation.x += p.userData.rotVel.x;
                p.rotation.y += p.userData.rotVel.y;
                p.userData.vel.y -= 18.0 * delta; 

                if (p.position.y < -3) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        const clock = new THREE.Clock();
        let spawnTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (isPlaying) {
                targets.forEach(t => t.update(delta));
                updateParticles(delta);

                spawnTimer += delta;
                let spawnRate = 0.8 - (GAME_DURATION - timeLeft) * 0.015;
                if (spawnRate < 0.3) spawnRate = 0.3;

                if (spawnTimer > spawnRate) { 
                    const hiddenTargets = targets.filter(t => t.state === 'HIDDEN');
                    if (hiddenTargets.length > 0) {
                        const idx = Math.floor(Math.random() * hiddenTargets.length);
                        hiddenTargets[idx].appear();
                    }
                    spawnTimer = 0;
                }

                timeLeft -= delta;
                document.getElementById('timer').innerText = `TIME: ${Math.ceil(timeLeft)}`;
                if (timeLeft <= 0) {
                    endGame("TIME UP!");
                }
            } else {
                updateParticles(delta);
            }
            renderer.render(scene, camera);
        }

        function onPointerDown(event) {
            if (!isPlaying) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            for (let i = 0; i < intersects.length; i++) {
                const obj = intersects[i].object;
                if (obj.userData && obj.userData.parent) {
                    const target = obj.userData.parent;
                    const result = target.hit();

                    if (result === 'HIT') {
                        playSlapSound(); 
                        setTimeout(() => playVoice('NORMAL'), 60);

                        showHitEffect(event.clientX, event.clientY, "SMACK!");
                        createConfetti(target.mesh.position.x, 0.8, target.mesh.position.z, target.pantyMat.color);
                        
                        score += 10;
                        document.getElementById('score-board').innerText = `SCORE: ${score}`;
                        if (navigator.vibrate) navigator.vibrate(50);

                    } else if (result === 'GAME_OVER') {
                        playSlapSound();
                        setTimeout(() => playVoice('UNCLE'), 50);
                        
                        showHitEffect(event.clientX, event.clientY, "NOOO!");
                        if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 500]);
                        
                        setTimeout(() => endGame("GAME OVER"), 1000);
                    }
                    break;
                }
            }
        }

        function playVoice(type) {
            if (!('speechSynthesis' in window)) return;
            speechSynth.cancel();

            let text, pitch, rate;

            if (type === 'UNCLE') {
                text = "ブフォオォォッ！...グヒヒヒ..."; // より汚く、不気味に
                pitch = 0.3; // 聞き取りやすく少し上げるが低いまま
                rate = 0.6; // 少しねっとり
            } else {
                const texts = ["あぁっ", "きゃっ", "もうっ", "いやっ"];
                text = texts[Math.floor(Math.random() * texts.length)];
                pitch = 1.4 + Math.random() * 0.4; 
                rate = 1.1;
            }

            const utter = new SpeechSynthesisUtterance(text);
            utter.pitch = pitch;
            utter.rate = rate;
            
            if (type === 'UNCLE') {
                if (maleVoice) utter.voice = maleVoice;
            } else {
                if (jpVoice) utter.voice = jpVoice;
            }
            
            utter.volume = 1.0;
            speechSynth.speak(utter);
        }

        function showHitEffect(x, y, text) {
            const el = document.createElement('div');
            el.className = 'hit-text';
            el.innerText = text;
            el.style.left = Math.min(x, window.innerWidth - 100) + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const startBtn = document.getElementById('start-btn');
        const quitBtn = document.getElementById('quit-btn');
        const overlay = document.getElementById('overlay');

        startBtn.addEventListener('click', () => {
            initAudio(); 
            startGame();
        });
        quitBtn.addEventListener('click', stopGame);

        function startGame() {
            loadVoices();
            score = 0;
            timeLeft = GAME_DURATION;
            document.getElementById('score-board').innerText = `SCORE: 0`;
            overlay.classList.add('hidden');
            isPlaying = true;
            speechSynth.cancel();
            
            targets.forEach(t => t.reset(false));
            
            targets.forEach(t => {
                t.mesh.position.y = t.baseY;
                t.state = 'HIDDEN';
            });
            
            particles.forEach(p => scene.remove(p));
            particles = [];

            playBGM();
        }

        function stopGame() {
            isPlaying = false;
            stopBGM();
            overlay.classList.remove('hidden');
            // 初期画面の状態に戻す
            document.getElementById('title-text').innerHTML = "THE SPANKING<br>CIRCUS";
            document.getElementById('desc-text').innerHTML = "Ladies and Gentlemen...<br>今宵の出し物は「尻叩き」でございます。<br>パンツを吹き飛ばし、悲鳴を上げさせましょう...<br><span class=\"warning\">※異形の尻（おじさん）には触れてはいけません...</span>";
            document.getElementById('start-btn').innerText = "ENTER SHOW";
        }

        function endGame(title) {
            isPlaying = false;
            stopBGM();
            overlay.classList.remove('hidden');
            document.getElementById('title-text').innerText = title;
            let msg = "";
            if (title === "GAME OVER") {
                msg = `異形の尻を触ってしまいました...<br>SCORE: ${score}`;
            } else {
                msg = `TOTAL SCORE: ${score}<br>素晴らしい手捌きでした。`;
            }
            document.getElementById('desc-text').innerHTML = msg;
            document.getElementById('start-btn').innerText = "ENCORE";
        }

        init();
    </script>
</body>
</html>
